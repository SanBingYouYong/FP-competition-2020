import Graphics.Gloss
import Prelude

-- main function which will display the graphic
main :: IO ()
main = fast True

-- secondary main function which shows the underlying fractal on its own without the expanding white lines
main' :: IO ()
main' = slow False

-- The following 2 functions can be called directly with a Boolean value which determines whether the changing white circles will be displayed.
-- True to display (eg. >fast True or >slow True)
-- False to hide   (eg. >fast False or >slow False)

-- Displaying the window and calling picture with time, which is generated by the "animate" function, and a boolean value for displaying white circles.
fast :: Bool -> IO ()
fast b = animate (InWindow "Fractal Circles" 
                (900, 900) 
                (20, 20)) 
                black (pictureF b)
                
slow :: Bool -> IO ()
slow b = animate (InWindow "Fractal Circles" 
                (900, 900) 
                (20, 20)) 
                black (pictureS b)

-- Giving an appropriate scale to, and rotating every item generated by "fractal" depth 6
pictureF :: Bool -> Float -> Picture
pictureF b time = Scale 120 120
               $ Rotate (time * 850) -- this fractal will rotate faster
               $ fractal b 6 (time)
               
pictureS :: Bool -> Float -> Picture
pictureS b time = Scale 120 120
               $ Rotate (time * 100) -- this fractal will rotate slower
               $ fractal b 6 (time)
               
colors :: [ Color ]
colors
 =      [ red
        , orange
        , yellow
        , chartreuse
        , green
        , aquamarine
        , cyan
        , azure
        , blue
        , violet
        , magenta
        , rose
        ] 

-- function to build the fractal, recieves whether to display the expanding circles, number of iterations and time 
fractal :: Bool -> Int -> Float -> Picture      
fractal showLines 0 _ = Blank     -- if number of iterations is 0 the picture is blank
fractal showLines n t = Pictures [ripples, circle1, circle2, circle3, line]   
    where 
        -- offsets to circles relative to origin
        pos1 = 1 / sin (pi/3)       
        pos2 = pos1 * cos (pi/3)
        
        -- every even fractal generated will rotate the opposite direction from the odd
        rot | n `mod` 2 == 0 = 50 * t
            | otherwise = (-50) * t
        
        -- main circle fractal generator: creates a circle then calls fractal on a smaller scale
        circGen =
            Pictures [ Color custColor $ circle 1,
                       Scale (pos1/2.5) (pos1/2.5) $ fractal showLines (n-1) t ] 
        
        -- creates white circles which change in size with time following the sine wave
        circ0 =
            Pictures [ Scale (1 + sin(t)) (1 + sin(t)) 
                      $ Color white $ Circle (10) ]
                      
        -- In order to not oversaturate the animation with white circles only call "circ0" every even iteration of "fractal"
        ripples | n `mod` 2 == 0 && showLines == True = circ0
                | otherwise = Blank
        
        -- Places the fractal created by "circGen" in 3 different locations with different rotations
        circle1 = Translate 0 pos1 $ Rotate rot circGen
        circle2 = Translate 1 (-pos2) $ Rotate (-rot) circGen
        circle3 = Translate (-1) (-pos2) $ Rotate rot circGen
        
        -- Generates red lines which connect the "origin" to the three positions where the fractal is placed, but only for the first 3 iterations
        line | n >= 4 = Pictures [ Color red $ Line [(0,0), (0,pos1)],
                                   Color red $ Line [(0,0), (1, -pos2)],
                                   Color red $ Line [(0,0), (-1, -pos2)] 
                                 ]
             | otherwise = Blank
        
        -- colors changing with time following the sine wave
        custColor = makeColor sred sgreen sblue 1
        
        sred    = sin (t + 0)
        sgreen  = sin (t + 2)
        sblue   = sin (t + 4)
